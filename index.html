<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spanish Checkers (Damas)</title>
<style>
  :root{
    --bg:#111827; --panel:#0f1724; --wood-dark:#5a3d2e; --wood-light:#e0c097;
    --blue:#2b86c9; --red:#c6362f;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#07101a);font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#fff}
  .app{display:flex;flex-direction:column;align-items:center;padding:12px;gap:12px}
  .hud{display:flex;gap:10px;align-items:center}
  .card{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  #board{width:92vmin;max-width:720px;aspect-ratio:1/1;border-radius:14px;overflow:hidden;border:8px solid #3b2b20;background:linear-gradient(180deg,var(--wood-dark),#6a4a35);display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr)}
  .cell{display:flex;align-items:center;justify-content:center;touch-action:manipulation;position:relative}
  .cell.light{background:var(--wood-light)}
  .cell.dark{background:var(--wood-dark)}
  .highlight{box-shadow:0 0 0 4px rgba(255,255,0,0.22) inset;border-radius:8px}
  .piece{width:78%;height:78%;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;user-select:none;box-shadow:0 6px 14px rgba(0,0,0,0.5);transition:transform .12s}
  .piece:active{transform:scale(.96)}
  .blue{background:linear-gradient(180deg,var(--blue),#1260a0);color:#fff}
  .red{background:linear-gradient(180deg,var(--red),#8a201b);color:#fff}
  .king{box-shadow:0 0 10px gold,0 6px 14px rgba(0,0,0,0.5);border:3px solid rgba(255,215,0,0.9)}
  .controls{display:flex;gap:8px;align-items:center}
  select,button{padding:8px 12px;border-radius:10px;border:none;background:rgba(255,255,255,0.06);color:#fff;font-weight:600;cursor:pointer}
  .status{font-weight:700}
  @media (max-width:420px){ .piece{width:86%;height:86%;font-size:14px} select,button{font-size:14px;padding:8px} }
</style>
</head>
<body>
<div class="app">
  <div class="hud">
    <div class="card controls">
      <label>Mode </label>
      <select id="mode">
        <option value="pvp">2-Player</option>
        <option value="easy">AI Easy</option>
        <option value="medium">AI Medium</option>
        <option value="hard">AI Hard</option>
      </select>
      <button id="restartBtn">Restart</button>
    </div>
    <div class="card status" id="status">Blue to move</div>
    <div class="card" id="score">Blue:12 &nbsp; Red:12</div>
  </div>

  <div id="board" role="grid" aria-label="Checkers board"></div>
</div>

<script>
/* Spanish Checkers (Damas) - single-file implementation
   - Spanish rules: men move forward 1; men capture forward only;
     kings (dama) fly & capture any direction long-range; mandatory capture;
     longest-capture precedence; tie-break by kings captured.
   - Modes: PvP, AI Easy/Medium/Hard (Hard = minimax depth 4)
*/

const SIZE = 8;
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const scoreEl = document.getElementById('score');
const modeSel = document.getElementById('mode');
const restartBtn = document.getElementById('restartBtn');

let board = [];
let turn = 'blue'; // blue (human bottom) moves up (r--), red (AI/top) moves down (r++)
let selected = null;
let legalTargets = []; // [{r,c,seq}] seq = {steps:[{r,c}], captures:[{r,c,color,isKing}], kingsCaptured}
let mode = 'pvp';
let blueCount = 12, redCount = 12;

// sounds placeholders (user may replace src)
const moveSound = new Audio();
const captureSound = new Audio();
const winSound = new Audio();
// optional: set moveSound.src = 'move.mp3' etc.

modeSel.addEventListener('change', ()=>{ mode = modeSel.value; });
restartBtn.addEventListener('click', init);

function init(){
  // build starting board: red top 3 rows, blue bottom 3 rows on dark squares
  board = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
  for(let r=0;r<3;r++) for(let c=0;c<SIZE;c++) if((r+c)%2===1) board[r][c] = {color:'red', king:false};
  for(let r=5;r<8;r++) for(let c=0;c<SIZE;c++) if((r+c)%2===1) board[r][c] = {color:'blue', king:false};
  turn = 'blue';
  selected = null;
  legalTargets = [];
  blueCount = 12; redCount = 12;
  render();
  updateStatus();
  if(mode !== 'pvp' && turn==='red') setTimeout(aiTurn,300);
}

function render(){
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${SIZE},1fr)`;
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const cell = document.createElement('div');
      cell.className = 'cell ' + (((r+c)%2)?'dark':'light');
      cell.dataset.r = r; cell.dataset.c = c;
      cell.addEventListener('click', ()=>onCellClick(r,c));
      if(selected && selected.r===r && selected.c===c) cell.classList.add('highlight');
      const p = board[r][c];
      if(p){
        const el = document.createElement('div');
        el.className = 'piece ' + p.color + (p.king?' king':'');
        el.textContent = p.king ? 'â—ˆ' : '';
        cell.appendChild(el);
      } else {
        // show legal landing highlights
        const t = legalTargets.find(t=>t.r===r && t.c===c);
        if(t) cell.classList.add('highlight');
      }
      boardEl.appendChild(cell);
    }
  }
  updateScore();
}

function updateScore(){
  let b=0, rr=0;
  for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
    const p = board[r][c]; if(p){ if(p.color==='blue') b++; else rr++; }
  }
  blueCount=b; redCount=rr;
  scoreEl.textContent = `Blue:${blueCount}  Red:${redCount}`;
}

function updateStatus(msg){
  if(msg) statusEl.textContent = msg;
  else statusEl.textContent = (turn==='blue') ? 'Blue to move' : (mode==='pvp' ? 'Red to move' : 'Computer (Red) thinking...');
}

// --- Helpers: clone board (deep) ---
function cloneBoard(b){
  return b.map(row => row.map(cell => cell ? {color:cell.color, king:cell.king} : null));
}

// --- Inside check ---
function inside(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }

// --- Generate capture sequences (DFS) for Spanish rules
// returns array of sequences {landR, landC, captures:[{r,c,color,isKing}], kingsCaptured, length}
function generateCaptureSequences(r, c, b){
  const p = b[r][c];
  if(!p) return [];
  const color = p.color;
  const isKing = p.king;

  const sequences = [];

  if(!isKing){
    // Men: capture forward only (Spanish)
    const dirs = (color==='blue') ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]];
    function dfs_m(r0,c0,boardState,accCapt){
      let found = false;
      for(const [dr,dc] of dirs){
        const mr=r0+dr, mc=c0+dc, lr=r0+2*dr, lc=c0+2*dc;
        if(inside(lr,lc) && boardState[mr]?.[mc] && boardState[mr][mc].color !== color && !boardState[lr][lc]){
          // clone board for recursion: mark captured (but don't remove until finishing if we wanted Spanish timing,
          // here we remove to avoid recapturing same piece)
          const nb = cloneBoard(boardState);
          nb[mr][mc] = null;
          nb[lr][lc] = nb[r0][c0];
          nb[r0][c0] = null;
          const newAcc = accCapt.concat([{r:mr,c:mc, color: boardState[mr][mc].color, isKing: boardState[mr][mc].king}]);
          const deeper = dfs_m(lr,lc,nb,newAcc);
          if(!deeper.length) {
            sequences.push({landR:lr, landC:lc, captures:newAcc.slice(), kingsCaptured: newAcc.filter(x=>x.isKing).length, length:newAcc.length});
          } else found = true;
        }
      }
      if(!found) return [];
      return [true];
    }
    // start DFS
    dfs_m(r,c,b,[]);
    return sequences;
  } else {
    // King: flying captures in all directions; can capture a piece (any distance) and land any empty square beyond; captured piece removed for continuation
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    function dfs_k(r0,c0,boardState,accCapt){
      let any = false;
      for(const [dr,dc] of dirs){
        let mr = r0+dr, mc=c0+dc;
        // scan until find opponent piece
        while(inside(mr,mc) && !boardState[mr][mc]){
          mr += dr; mc += dc;
        }
        if(inside(mr,mc) && boardState[mr][mc] && boardState[mr][mc].color !== color){
          // after an enemy, landing squares are any empty square beyond it along same diagonal
          let lr = mr+dr, lc = mc+dc;
          while(inside(lr,lc)){
            if(boardState[lr][lc]) break; // blocked further
            // simulate capture landing at (lr,lc)
            const nb = cloneBoard(boardState);
            nb[mr][mc] = null;
            nb[lr][lc] = nb[r0][c0];
            nb[r0][c0] = null;
            const newAcc = accCapt.concat([{r:mr,c:mc,color:boardState[mr][mc].color,isKing:boardState[mr][mc].king}]);
            const deeper = dfs_k(lr,lc,nb,newAcc);
            if(!deeper.length){
              sequences.push({landR:lr, landC:lc, captures:newAcc.slice(), kingsCaptured:newAcc.filter(x=>x.isKing).length, length:newAcc.length});
            } else any = true;
            lr += dr; lc += dc;
          }
        }
      }
      if(!any) return [];
      return [true];
    }
    dfs_k(r,c,b,[]);
    return sequences;
  }
}

// --- Generate non-capture moves for a piece (Spanish)
function generateNonCaptureMoves(r,c,b){
  const p = b[r][c]; if(!p) return [];
  const res = [];
  if(!p.king){
    const dirs = (p.color==='blue') ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]];
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(inside(nr,nc) && !b[nr][nc]) res.push({landR:nr,landC:nc});
    }
  } else {
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [dr,dc] of dirs){
      let nr=r+dr, nc=c+dc;
      while(inside(nr,nc) && !b[nr][nc]){
        res.push({landR:nr, landC:nc});
        nr+=dr; nc+=dc;
      }
    }
  }
  return res;
}

// --- Collect all legal moves for a color, applying Spanish precedence (longest capture, tie-break kings)
function collectAllLegalMoves(color, b){
  const allSeq = [];
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
    const p = b[r][c];
    if(p && p.color===color){
      const caps = generateCaptureSequences(r,c,b);
      for(const s of caps){
        allSeq.push({fromR:r,fromC:c, toR:s.landR, toC:s.landC, captures:s.captures, length:s.length, kingsCaptured:s.kingsCaptured, isCapture:true});
      }
    }
  }
  if(allSeq.length>0){
    // choose only sequences with maximum length, then tie-break by kingsCaptured
    let maxLen = Math.max(...allSeq.map(x=>x.length));
    let candidates = allSeq.filter(x=>x.length===maxLen);
    let maxKings = Math.max(...candidates.map(x=>x.kingsCaptured));
    candidates = candidates.filter(x=>x.kingsCaptured===maxKings);
    return candidates;
  }
  // no captures: normal moves
  const normals = [];
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
    const p=b[r][c];
    if(p && p.color===color){
      const nm = generateNonCaptureMoves(r,c,b);
      for(const m of nm) normals.push({fromR:r,fromC:c,toR:m.landR,toC:m.landC,isCapture:false});
    }
  }
  return normals;
}

// --- Apply a move (sequence) to board; returns object {promoted:boolean, capturedCount}
function applyMove(move, b){
  // move: {fromR,fromC,toR,toC,isCapture, captures:[{r,c,color,isKing}]}
  const p = b[move.fromR][move.fromC];
  b[move.fromR][move.fromC] = null;
  b[move.toR][move.toC] = {color:p.color, king:p.king};
  // remove captured pieces (Spanish: remove as captured)
  let capturedCount = 0, kingsCaptured = 0;
  if(move.isCapture && move.captures && move.captures.length){
    for(const cap of move.captures){
      if(b[cap.r] && b[cap.r][cap.c]){ b[cap.r][cap.c] = null; capturedCount++; if(cap.isKing) kingsCaptured++; }
    }
  }
  // promotion: in Spanish, promotion happens when landing on back rank and piece becomes king immediately (move ends)
  if(!p.king){
    if(p.color==='blue' && move.toR===0){ b[move.toR][move.toC].king = true; }
    if(p.color==='red' && move.toR===SIZE-1){ b[move.toR][move.toC].king = true; }
  }
  return {capturedCount, kingsCaptured, promoted: b[move.toR][move.toC].king && !p.king};
}

// --- UI interactions
function onCellClick(r,c){
  if(turn !== 'blue' && !(mode==='pvp' && turn==='red')) return;
  // compute all legal moves for player and enforce capture precedence
  const allLegal = collectAllLegalMoves(turn, board);
  const hasCapture = allLegal.some(m=>m.isCapture);
  const p = board[r][c];
  if(p && p.color === turn){
    // selecting a piece: compute its legal sequences (filtered by global precedence)
    const myMoves = allLegal.filter(m=>m.fromR===r && m.fromC===c);
    selected = {r,c};
    legalTargets = myMoves.map(m=> ({r:m.toR,c:m.toC, move:m}) );
    render();
  } else if(selected){
    // if clicked a highlighted target, execute move
    const t = legalTargets.find(t=>t.r===r && t.c===c);
    if(t){
      // execute t.move
      applyMove(t.move, board);
      // after capture move, check if that same piece has further capture sequences (must continue)
      if(t.move.isCapture){
        // find sequences from landing square on the current board (note that we already removed captured pieces)
        const contSeq = generateCaptureSequences(t.r, t.c, board);
        if(contSeq.length>0){
          // choose only longest & kings tie-break but for continuation these are straightforward: require player to continue using that same piece
          // convert contSeq to legalTargets
          legalTargets = contSeq.map(s=>({r:s.landR,c:s.landC, move:{fromR:t.r,fromC:t.c,toR:s.landR,toC:s.landC,isCapture:true,captures:s.captures}}));
          selected = {r:t.r,c:t.c};
          render();
          updateAfterMove();
          return; // player continues
        }
      }
      // otherwise end move and switch turn
      selected = null; legalTargets = [];
      render();
      updateAfterMove();
      setTimeout(()=>{ turn = (turn==='blue') ? 'red' : 'blue'; updateStatus(); if(mode!=='pvp' && turn==='red') setTimeout(aiTurn, 300); }, 120);
    }
  }
}

function updateAfterMove(){
  updateScore();
  updateStatus();
}

// --- AI: easy/medium/hard
function aiTurn(){
  if(turn!=='red') return;
  updateStatus();
  // get legal moves for AI
  const legal = collectAllLegalMoves('red', board);
  if(!legal.length){ updateStatus('Blue wins!'); winSound.play(); return; }
  let choice;
  if(mode==='easy'){
    choice = legal[Math.floor(Math.random()*legal.length)];
  } else if(mode==='medium'){
    const caps = legal.filter(m=>m.isCapture);
    choice = (caps.length>0) ? caps[Math.floor(Math.random()*caps.length)] : legal[Math.floor(Math.random()*legal.length)];
  } else {
    // Hard: minimax depth 4 (AI = maximizing for red)
    choice = minimaxRoot(board, 4);
    if(!choice) choice = legal[Math.floor(Math.random()*legal.length)];
  }
  // execute chosen move (and handle continuation)
  applyMove(choice, board);
  // handle continuation for king/multi-capture
  if(choice.isCapture){
    const cont = generateCaptureSequences(choice.toR, choice.toC, board);
    if(cont.length>0){
      // pick best continuation greedily (for AI)
      // apply the best available continuation sequence until no more
      let best;
      // choose continuation with max length then kingsCaptured
      let maxL = Math.max(...cont.map(s=>s.length));
      let cands = cont.filter(s=>s.length===maxL);
      let maxK = Math.max(...cands.map(s=>s.kingsCaptured));
      cands = cands.filter(s=>s.kingsCaptured===maxK);
      best = cands[ Math.floor(Math.random()*cands.length) ];
      applyMove({fromR:choice.toR,fromC:choice.toC,toR:best.landR,toC:best.landC,isCapture:true,captures:best.captures}, board);
      // continue loop if deeper captures exist
      let curR = best.landR, curC = best.landC;
      while(true){
        const next = generateCaptureSequences(curR, curC, board);
        if(next.length===0) break;
        let maxL = Math.max(...next.map(s=>s.length));
        let cands = next.filter(s=>s.length===maxL);
        let maxK = Math.max(...cands.map(s=>s.kingsCaptured));
        cands = cands.filter(s=>s.kingsCaptured===maxK);
        const pick = cands[Math.floor(Math.random()*cands.length)];
        applyMove({fromR:curR,fromC:curC,toR:pick.landR,toC:pick.landC,isCapture:true,captures:pick.captures}, board);
        curR = pick.landR; curC = pick.landC;
      }
    }
  }
  // switch back to player
  turn = 'blue';
  updateAfterMove();
}

// --- Minimax (Hard AI)
function evaluateBoard(b){
  // evaluation: pawn=3, king=6, positional small bonus
  let score = 0;
  for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
    const p = b[r][c];
    if(p){
      const val = p.king ? 6 : 3;
      score += (p.color==='red') ? val : -val;
      // mobility bonus
      const moves = collectAllLegalMoves(p.color, b);
      // skip heavy computation; small positional bonus
      if(p.color==='red') score += (p.color==='red' && p.king ? 0.1 : 0);
    }
  }
  return score;
}

function minimax(boardState, depth, alpha, beta, maximizingPlayer){
  if(depth===0) return evaluateBoard(boardState);
  const color = maximizingPlayer ? 'red' : 'blue';
  const moves = collectAllLegalMoves(color, boardState);
  if(moves.length===0) return evaluateBoard(boardState);
  if(maximizingPlayer){
    let maxEval = -Infinity;
    for(const mv of moves){
      const nb = cloneBoard(boardState);
      applyMove(mv, nb);
      // for captures try to apply forced continuations greedily (simulate)
      if(mv.isCapture){
        let curR = mv.toR, curC = mv.toC;
        while(true){
          const cont = generateCaptureSequences(curR, curC, nb);
          if(cont.length===0) break;
          // pick the longest/kings-best continuation for simulation
          let maxL = Math.max(...cont.map(s=>s.length));
          let cand = cont.filter(s=>s.length===maxL);
          let maxK = Math.max(...cand.map(s=>s.kingsCaptured));
          cand = cand.filter(s=>s.kingsCaptured===maxK);
          const pick = cand[0];
          applyMove({fromR:curR,fromC:curC,toR:pick.landR,toC:pick.landC,isCapture:true,captures:pick.captures}, nb);
          curR = pick.landR; curC = pick.landC;
        }
      }
      const evalScore = minimax(nb, depth-1, alpha, beta, false);
      maxEval = Math.max(maxEval, evalScore);
      alpha = Math.max(alpha, evalScore);
      if(beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for(const mv of moves){
      const nb = cloneBoard(boardState);
      applyMove(mv, nb);
      if(mv.isCapture){
        let curR = mv.toR, curC = mv.toC;
        while(true){
          const cont = generateCaptureSequences(curR, curC, nb);
          if(cont.length===0) break;
          let maxL = Math.max(...cont.map(s=>s.length));
          let cand = cont.filter(s=>s.length===maxL);
          let maxK = Math.max(...cand.map(s=>s.kingsCaptured));
          cand = cand.filter(s=>s.kingsCaptured===maxK);
          const pick = cand[0];
          applyMove({fromR:curR,fromC:curC,toR:pick.landR,toC:pick.landC,isCapture:true,captures:pick.captures}, nb);
          curR = pick.landR; curC = pick.landC;
        }
      }
      const evalScore = minimax(nb, depth-1, alpha, beta, true);
      minEval = Math.min(minEval, evalScore);
      beta = Math.min(beta, evalScore);
      if(beta <= alpha) break;
    }
    return minEval;
  }
}

function minimaxRoot(boardState, depth){
  const moves = collectAllLegalMoves('red', boardState);
  if(moves.length===0) return null;
  let best = moves[0];
  let bestScore = -Infinity;
  for(const mv of moves){
    const nb = cloneBoard(boardState);
    applyMove(mv, nb);
    // greedy continuation simulation for captures
    if(mv.isCapture){
      let curR = mv.toR, curC = mv.toC;
      while(true){
        const cont = generateCaptureSequences(curR, curC, nb);
        if(cont.length===0) break;
        let maxL = Math.max(...cont.map(s=>s.length));
        let cand = cont.filter(s=>s.length===maxL);
        let maxK = Math.max(...cand.map(s=>s.kingsCaptured));
        cand = cand.filter(s=>s.kingsCaptured===maxK);
        const pick = cand[0];
        applyMove({fromR:curR,fromC:curC,toR:pick.landR,toC:pick.landC,isCapture:true,captures:pick.captures}, nb);
        curR = pick.landR; curC = pick.landC;
      }
    }
    const score = minimax(nb, depth-1, -Infinity, Infinity, false);
    if(score > bestScore){ bestScore = score; best = mv; }
  }
  return best;
}

// init at load
init();
</script>
</body>
</html>
