<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Myanmar Checkers</title>
<style>
  body {
    font-family: sans-serif;
    text-align: center;
    background: linear-gradient(135deg, #1e293b, #0f172a);
    color: white;
    margin: 0;
  }
  h1 { margin: 10px 0; font-size: 1.5rem; }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    width: 90vmin; height: 90vmin;
    margin: 10px auto;
    border: 4px solid #334155;
    border-radius: 15px;
    overflow: hidden;
  }
  .cell {
    display: flex; align-items: center; justify-content: center;
    font-size: 2rem; user-select: none;
  }
  .dark { background: #475569; }
  .light { background: #94a3b8; }
  .piece {
    width: 80%; height: 80%;
    border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,.4);
  }
  .blue { background: #3b82f6; }
  .yellow { background: #facc15; }
  .king { border: 3px solid white; }
  .highlight { outline: 3px solid #22c55e; }
  button {
    padding: 10px 20px;
    font-size: 1rem;
    margin: 10px;
    border: none; border-radius: 8px;
    background: #3b82f6; color: white;
    box-shadow: 0 3px 6px rgba(0,0,0,.3);
  }
  #status { margin: 5px; font-weight: bold; }
</style>
</head>
<body>
<h1>Myanmar Checkers</h1>
<div id="status">Your turn (Blue)</div>
<div id="board"></div>
<button onclick="restart()">Restart</button>
<script>
const size=8;
let board,turn,selected,moves;
const boardEl=document.getElementById("board");
const statusEl=document.getElementById("status");

function inside(r,c){return r>=0&&r<size&&c>=0&&c<size;}

function initBoard(){
  board=Array.from({length:size},()=>Array(size).fill(null));
  // Yellow (AI) at top
  for(let r=0;r<3;r++){
    for(let c=0;c<size;c++) if((r+c)%2===1) board[r][c]={color:"yellow",king:false};
  }
  // Blue (Human) at bottom
  for(let r=size-3;r<size;r++){
    for(let c=0;c<size;c++) if((r+c)%2===1) board[r][c]={color:"blue",king:false};
  }
  turn="blue"; selected=null; moves=[];
}

function render(){
  boardEl.innerHTML="";
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      const cell=document.createElement("div");
      cell.className="cell "+(((r+c)%2)?"dark":"light");
      cell.onclick=()=>select(r,c);
      if(board[r][c]){
        const p=document.createElement("div");
        p.className="piece "+board[r][c].color+(board[r][c].king?" king":"");
        cell.appendChild(p);
      }
      if(selected && selected.r===r && selected.c===c) cell.classList.add("highlight");
      if(moves.some(m=>m.r===r&&m.c===c)) cell.classList.add("highlight");
      boardEl.appendChild(cell);
    }
  }
}

function select(r,c){
  if(turn!=="blue")return;
  if(board[r][c]&&board[r][c].color==="blue"){
    selected={r,c};
    moves=legalMoves(r,c);
    render();
  } else if(selected){
    const m=moves.find(x=>x.r===r&&x.c===c);
    if(m){ doMove(selected.r,selected.c,m); render(); }
  }
}

// === MOVE GENERATION ===
function legalMoves(r,c){
  const p=board[r][c]; if(!p) return [];
  let moves=[];

  if(!p.king){
    // Forward directions only
    const forwardDirs = p.color==="blue" ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]];

    // âœ… Normal move
    for(const[dr,dc] of forwardDirs){
      const nr=r+dr, nc=c+dc;
      if(inside(nr,nc)&&!board[nr][nc]){
        moves.push({r:nr,c:nc,captures:[],isCapture:false});
      }
    }

    // âœ… Forward captures only
    for(const[dr,dc] of forwardDirs){
      const mr=r+dr, mc=c+dc, lr=r+2*dr, lc=c+2*dc;
      if(inside(lr,lc)&&board[mr]?.[mc]&&board[mr][mc].color!==p.color&&!board[lr][lc]){
        moves.push({r:lr,c:lc,captures:[{r:mr,c:mc}],isCapture:true});
      }
    }
  } else {
    // Flying king
    const dirs=[[1,-1],[1,1],[-1,-1],[-1,1]];
    for(const[dr,dc] of dirs){
      let nr=r+dr,nc=c+dc,captured=null;
      while(inside(nr,nc)){
        if(!board[nr][nc]&&!captured){
          moves.push({r:nr,c:nc,captures:[],isCapture:false});
        } else if(board[nr][nc]&&board[nr][nc].color!==p.color&&!captured){
          captured={r:nr,c:nc};
        } else if(captured&&!board[nr][nc]){
          moves.push({r:nr,c:nc,captures:[captured],isCapture:true});
        } else break;
        nr+=dr; nc+=dc;
      }
    }
  }

  // Enforce capture rule
  if(moves.some(m=>m.isCapture)){
    const maxCap=Math.max(...moves.map(m=>m.captures.length));
    return moves.filter(m=>m.isCapture&&m.captures.length===maxCap);
  }
  return moves;
}

function doMove(r,c,m){
  const p=board[r][c]; board[r][c]=null; board[m.r][m.c]=p;
  m.captures.forEach(cap=>board[cap.r][cap.c]=null);
  if((p.color==="blue"&&m.r===0)||(p.color==="yellow"&&m.r===size-1)) p.king=true;

  if(m.isCapture){
    const further=legalMoves(m.r,m.c).filter(x=>x.isCapture);
    if(further.length&&turn==="blue"){
      selected={r:m.r,c:m.c}; moves=further; render(); return;
    }
  }
  turn=(turn==="blue"?"yellow":"blue");
  selected=null;moves=[];render();
  if(turn==="yellow") setTimeout(aiMove,500);
}

function playerMoves(color){
  let res=[];
  for(let r=0;r<size;r++)for(let c=0;c<size;c++){
    if(board[r][c]?.color===color){
      let ms=legalMoves(r,c);
      if(ms.length) res.push({r,c,m:ms});
    }
  }
  return res;
}

// === AI ===
function aiMove(){
  if(turn!=="yellow")return;
  const movesets=playerMoves("yellow");
  if(!movesets.length){
    statusEl.textContent="ðŸŽ‰ You win!";
    turn="end"; return;
  }
  let allMoves=[];
  movesets.forEach(s=>s.m.forEach(m=>allMoves.push({fr:s.r,fc:s.c,m})));

  let captureMoves=allMoves.filter(x=>x.m.isCapture);
  let choice;
  if(captureMoves.length){
    let maxKill=Math.max(...captureMoves.map(m=>m.m.captures.length));
    let best=captureMoves.filter(m=>m.m.captures.length===maxKill);
    choice=best[Math.floor(Math.random()*best.length)];
  } else {
    choice=allMoves[Math.floor(Math.random()*allMoves.length)];
  }

  function exec(fr,fc,m){
    doMove(fr,fc,m); render();
    if(turn==="yellow"){
      setTimeout(()=>{
        const next=legalMoves(m.r,m.c).filter(x=>x.isCapture);
        if(next.length){
          let maxKill=Math.max(...next.map(x=>x.captures.length));
          let best=next.filter(x=>x.captures.length===maxKill);
          let nc=best[Math.floor(Math.random()*best.length)];
          exec(m.r,m.c,nc);
        } else { turn="blue"; statusEl.textContent="Your turn (Blue)"; }
      },400);
    } else if(turn==="blue"){
      statusEl.textContent="Your turn (Blue)";
    }
  }
  exec(choice.fr,choice.fc,choice.m);
}

function restart(){initBoard();render();statusEl.textContent="Your turn (Blue)";}

initBoard();render();
</script>
</body>
</html>
